<!DOCTYPE HTML>
<!--
	TXT by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>物联网感知综合实习</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<header id="header">
					<div class="logo container">
						<div>
							<h1><a href="index.html" id="logo">小学期</a></h1>
							<p>作品合集</p>
						</div>
					</div>
				</header>

			<!-- Nav -->
				<nav id="nav">
					<ul>
						<li class="current"><a href="../index.html">Home</a></li>
						<li>
							<a href="#">Project</a>
							<ul>
								<li><a href="energy-conservation.html">节能减排竞赛</a></li>
								<li><a href="Epidemic prediction system.html">软件杯</a></li>
								<li>
									<a href="#">课程设计</a>
									<ul>
										<li><a href="Plane Wars.html">飞机大战</a></li>
										<li><a href="thermistor.html">热敏电阻传感器</a></li>
										<li><a href="TCP.html">TCP多线程简易聊天室</a></li>
										<li><a href="Iot awareness.html">物联网感知实习</a></li>
										<li><a href="database.html">数据库设计</a></li>
										<li><a href="STM32-clock.html">STM32电子表设计</a></li>
										<li><a href="Robert.html">智能小车自主驾驶</a></li>
										<li><a href="STM32-ZigBee.html">基于STM32和ZigBee的智能控锁系统</a></li>
									</ul>
								</li>
								<li>
									<a href="#">建模比赛</a>
									<ul>
										<li><a href="#">国赛</a></li>
										<li><a href="#">美赛</a></li>
										<li><a href="#">Mathorcup</a></li>
										<li><a href="#">电工杯</a></li>
										<li><a href="#">亚太</a></li>
									</ul>
								</li>
							</ul>
						</li>
						<li>
							<a href="#">Study</a>
							<ul>
								<li>
									<a href="#">蓝桥杯</a>
									<ul>
										<li><a href="#">c/c++组</a></li>
										<li><a href="#">嵌入式组</a></li>
									</ul>
								</li>
								<li>
									<a href="#">课程小结</a>
									<ul>
										<li><a href="../class/computer composition principle.html">计算机组成原理</a></li>
										<li><a href="../class/operating system.html">操作系统</a></li>
										<li><a href="../class/data structure.html">数据结构</a></li>
										<li><a href="../class/computer network.html">计算机网络</a></li>
										<li><a href="../class/database.html">数据库</a></li>
										<li><a href="../class/Machine Learning.html">机器学习</a></li>
										<li><a href="../class/Fundamentals of Compiling.html">编译原理</a></li>
									</ul>
								</li>
							</ul>
						</li>
						<li><a href="#">科研成果</a></li>
					</ul>
				</nav>

			<!-- Main -->
				<section id="main">
					<div class="container">
						<div class="row">
							<div class="col-12">
								<div class="content">

									<!-- Content -->

										<article class="box page-content">

											<header>
												<h2>物联网感知综合实习</h2>
												<ul class="meta">
													<li class="icon fa-clock">2021.7.15</li>
												</ul>
											</header>

											<section>
												<h3>1、皮带启停控制系统</h3>
												<dl>
												<dt><h4>题目要求</h4></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用单片机设计一皮带启停控制系统，如图1，分为ABCD四个皮带，A处是物料，需要通过皮带运送到D皮带末端。
												为了防止在开机时皮带上物料堆积，关机时物料压迫皮带，有以下要求
												</dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.开机顺序：D→C→B→A;关机顺序：A→B→C→D
												</dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.开启、关闭延时时间可调，通过按键设置
												</dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.设计上显示屏
												</dt>
												<dt align="center"><img src="images/IOT-1-0.jpg"></dt>
												<dt><h4>设计思路</h4></dt>
												<dt><b>硬件框图</b></dt>
												<dt align="center"><img src="images/IOT-1-1.jpg"></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑到Proteus里无法直接模拟出皮带的形状，为了简单直观的看出电机转动，选择了直流电机模拟皮带转动。
												通过查阅资料以及和同学交流，选择了L298N作为驱动模块。考虑到需要显示的是各种英文等，因此选用液晶显示屏。本题可以利用AT89C51的P3的第二功能，通过将按钮接到P3.2外中断0和P3.3外中断1，通过中断进行模式的切换与实现。
												</dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L298N是专用驱动集成电路，输出电流大，功率强，可以驱动大功率的直流电机。
												根据其逻辑功能表可知，其使能端ENA接高电平2时才能转动，因此直接将ENA端接电源，由于本题的皮带运送方向是固定的，因此只需要顺时针转动，顺时针转动需要IN1 = 1,IN2=0,因此可以将IN2接地，通过控制IN1来控制电机的开启与停止，IN3和IN4同理。
												</dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示屏选用LCD1602液晶显示屏，其RS为数据/命令选择端，RW为读/写选择端，EN为使能信号。其中常用的指令：38H显示模式设置，01H显示清屏，06H显示光标移动设置，0CH显示开及光标设置。
												通过指令来控制显示屏显示英文。
												</dt>
												<dt><b>Proteus仿真图</b></dt>
												<dt align="center"><img src="images/IOT-1-2.jpg"></dt>
												<dt><b>原理图</b></dt>
												<dt align="center"><img src="images/IOT-1-3.jpg"></dt>
												<dt><b>PCB版图</b></dt>
												<dt align="center"><img src="images/IOT-1-4.jpg"></dt>
												<dt><h4>编程实现</h4></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题的编程主要利用了外部中断0和外部中断1，当change键按下，即外部中断0，此时会去调用void Mode() interrupt 0这个中断处理函数，在此函数里，可以实现显示屏上字的切换，以及延时的调整；
												当enter键按下，即外部中断1，此时会调用void control() interrupt 2这个中断处理函数，在此函数中，可以处理控制L298N芯片，以此来驱动电机的转动。
												</dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总体流程图如下
												</dt>
												<dt align="center"><img src="images/IOT-1-5.jpg"></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于LCD液晶显示屏的控制，其相对流程如图，非常固定，其中使能端E是需要一个下降沿才能写入数据，因此需要先置1再置0
												</dt>
												<dt align="center"><img src="images/IOT-1-6.jpg"></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体代码如下
												</dt>
												<dt><pre>
		#include <reg51.h>
		#define uchar unsigned char
		#define uint  unsigned int

		sbit change = P1^5;
		sbit clear = P1^6;

		const uint cnt = 8;
		uint t = 0; 
		uint speed, distance;
		uint flag = 1, set = 1;
		uchar code table[16]={0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

		void delay(uchar m){
			uchar i,y;
			for(i = 0; i < m; i++)
				for(y = 0; y < 110; y++);
		}

		void init(){
			EX0 = 1;
			PX0 = 1;
			IT0 = 1;
			TMOD = 0x11;
			ET1 = 1;
			TR1 = 1;
			
			TH1 = (65535 - 25000) / 256;   
			TL1 = (65535 - 25000) % 256;
			EA=1;  

			distance = 0;	
		}

		void display(uint num){
			if(num >= 0 && num < 10){
				P2 = 0X08;
				P0 = table[num];        
				delay(3);
				P0 = 0XFF;
			}
			if(num >= 10 && num < 100){
				P2 = 0X08;
				P0 = table[num/10];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X04;
				P0 = table[num % 10];
				delay(3);
				P0 = 0XFF;
			}
			if(num >= 100 && num < 1000){
				P2 = 0X08;
				P0 = table[num / 100];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X04;
				P0 = table[num%100/10];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X02;
				P0 = table[num%100%10];
				delay(3);
				P0 = 0XFF;
			}
			if(num >= 1000 && num < 10000){
				P2 = 0X08;
				P0 = table[num/1000];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X04;
				P0 = table[num%1000/100];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X02;
				P0 = table[num%1000%100/10];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X01;
				P0 = table[num%1000%100%10];
				delay(3);
				P0 = 0XFF;
			}
		}

		void TIME1() interrupt 3{
			t++;
		}

		void main(){
			init();
			delay(10);
			while(1){
				speed = cnt * 2.2047 * 3.6;
				distance = cnt * 2.2047 * t * 0.001;
				if(change == 0){
					flag = -flag;
				}
				if(clear == 0){
					t = 0;
					distance = 0;
				}
				if(flag == 1){
					display(speed);
				}
				else{
					delay(10);
					display(distance);
				}
			}
		}										
												</pre></dt>
												<dt><h4>系统演示</h4></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍视频如下
												</dt>
												<dt align="center"><embed src="images/IOT-v1.mp4" height="550" width="960"/></dt>
												<dt><h4>本项目遇到的主要问题及解决方法</h4></dt>
												<dt>
												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本项目主要问题，就是之前所说的电机惯性问题，但在综合对比了步进电机，直流电机，伺服电机等，均无法消除惯性。
												在和同学讨论过程，以及结合同学说的，惯性本身也是实际中一部分，在仿真中应该不去消除，因此，未做消除惯性的处理
												</dt>
												</dl>
											</section>

											<section>
												<h3>2、广告牌设计</h3>
												<dl>
													<dt><h4>题目要求</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本项目是基于实际生活中，公交车后挡玻璃上的电子报站牌，要求用单片机设计一点阵结构的广告牌，可以循环显示汉字，每次按键切换下一个显示
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在题目要求基础上设计了三个按键：Last：切换到上一个显示；Next：切换到下一个显示；RST：切回第一个；
													</dt>
													<dt><h4>设计思路</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于是需要用点阵显示汉字，所以用了字模提取软件，直接得到其字模，如图所示。
													但是要显示汉字，需要16x16点阵，因此首先需要利用8x8点阵拼接16x16点阵
													</dt>
													<dt align="center"><img src="images/IOT-2-1.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于LED点阵扫描原理，是利用P0做行扫描，P2做传送数据端口。当P0口扫描第一行时，为10000000，即数据为0x80；
													P2口从P2.0-P2.7送入第一行要点亮的灯
													</dt>
													<dt align="center"><img src="images/IOT-2-2.jpg"></dt>
													<dt><b>硬件框图</b></dt>
													<dt align="center"><img src="images/IOT-2-3.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此设计参考了网上74LS138+74HC595设计。其中38译码器就是当E1为高电平，E2和E3为低电平时，可以将地址端的二进制编码在Y0到Y7对应的输出端以低电平输出。
													74HC595是移位寄存器，串行数据输入时钟(SHCP)和寄存器时钟(STCP)初始为低电平，DS输入数据，由于SHCP上升沿触发，因此SHCP变为高电平，DS数据进入移位寄存器中，STCP上升沿触发后，数据输入到存储寄存器中
													</dt>
													<dt><b>Proteus仿真图</b></dt>
													<dt align="center"><img src="images/IOT-2-4.jpg"></dt>
													<dt><b>原理图</b></dt>
													<dt align="center"><img src="images/IOT-2-5.jpg"></dt>
													<dt><b>PCB版图</b></dt>
													<dt align="center"><img src="images/IOT-2-6.jpg"></dt>
													<dt><h4>编程实现</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本项目程序流程比较清晰，就是通过设置好的数组利用State函数，分别取用不同数组实现汉字的切换，同理，Last按键和Next按键也是，设置好每个状态对应的上一个和下一个状态，
													调用时，只需要输入n，即可获取相应显示的汉字
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总体流程图如下
													</dt>
													<dt align="center"><img src="images/IOT-2-7.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体代码如下
													</dt>
													<dt><pre>
		#include <reg51.h>
		#define uchar unsigned char
		#define uint  unsigned int

		sbit SHCP = P2^0;
		sbit DS = P2^1;
		sbit STCP = P2^2;

		sbit Last = P2^4;
		sbit Next = P2^5;
		sbit Rst = P2^6;


		uchar code led1[] ={//山东科技大学
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,
		0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0xFC,0x1F,0x00,0x10,0x00,0x00,

		0x40,0x00,0x40,0x00,0x40,0x00,0xFE,0x3F,0x20,0x00,0x90,0x00,0x88,0x00,0x84,0x00,
		0xFC,0x1F,0x80,0x00,0x90,0x04,0x88,0x08,0x84,0x10,0x82,0x20,0xA0,0x00,0x40,0x00,

		0x10,0x08,0xB8,0x08,0x0F,0x09,0x08,0x09,0x08,0x08,0xBF,0x08,0x08,0x09,0x1C,0x09,
		0x2C,0x08,0x0A,0x78,0xCA,0x0F,0x09,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,

		0x08,0x04,0x08,0x04,0x08,0x04,0xC8,0x7F,0x3F,0x04,0x08,0x04,0x08,0x04,0xA8,0x3F,
		0x18,0x21,0x0C,0x11,0x0B,0x12,0x08,0x0A,0x08,0x04,0x08,0x0A,0x8A,0x11,0x64,0x60,

		0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xFF,0x7F,0x80,0x00,0x80,0x00,
		0x40,0x01,0x40,0x01,0x20,0x02,0x20,0x02,0x10,0x04,0x08,0x08,0x04,0x10,0x03,0x60,

		0x44,0x10,0x88,0x10,0x88,0x08,0x00,0x04,0xFE,0x7F,0x02,0x40,0x01,0x20,0xF8,0x07,
		0x00,0x02,0x80,0x01,0xFF,0x7F,0x80,0x00,0x80,0x00,0x80,0x00,0xA0,0x00,0x40,0x00,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		}; 

		uchar code led2[] ={//计算机科学
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			
		0x00,0x02,0x04,0x02,0x08,0x02,0x08,0x02,0x00,0x02,0x00,0x02,0xEF,0x7F,0x08,0x02,
		0x08,0x02,0x08,0x02,0x08,0x02,0x08,0x02,0x28,0x02,0x18,0x02,0x08,0x02,0x00,0x02,

		0x04,0x02,0x7C,0x7E,0x12,0x09,0x01,0x00,0xFC,0x1F,0x04,0x10,0xFC,0x1F,0x04,0x10,
		0xFC,0x1F,0x04,0x10,0xFC,0x1F,0x10,0x04,0xFF,0x7F,0x10,0x04,0x08,0x04,0x04,0x04,

		0x08,0x00,0x88,0x0F,0x88,0x08,0x88,0x08,0xBF,0x08,0x88,0x08,0x8C,0x08,0x9C,0x08,
		0xAA,0x08,0xAA,0x08,0x89,0x08,0x88,0x48,0x88,0x48,0x48,0x48,0x48,0x70,0x28,0x00,

		0x10,0x08,0xB8,0x08,0x0F,0x09,0x08,0x09,0x08,0x08,0xBF,0x08,0x08,0x09,0x1C,0x09,
		0x2C,0x08,0x0A,0x78,0xCA,0x0F,0x09,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,

		0x44,0x10,0x88,0x10,0x88,0x08,0x00,0x04,0xFE,0x7F,0x02,0x40,0x01,0x20,0xF8,0x07,
		0x00,0x02,0x80,0x01,0xFF,0x7F,0x80,0x00,0x80,0x00,0x80,0x00,0xA0,0x00,0x40,0x00,
			
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		}; 

		uchar code led3[] ={//物联网工程 
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			
		0x08,0x01,0x08,0x01,0x0A,0x01,0x0A,0x3F,0xBE,0x2A,0x4A,0x2A,0x09,0x2A,0x08,0x29,
		0x38,0x29,0x8F,0x24,0x4A,0x24,0x08,0x22,0x08,0x22,0x08,0x21,0x88,0x14,0x08,0x08,

		0x00,0x11,0x3F,0x12,0x12,0x0A,0x12,0x00,0x9E,0x3F,0x12,0x04,0x12,0x04,0x1E,0x04,
		0xD2,0x7F,0x12,0x04,0x32,0x0A,0x1E,0x0A,0x13,0x11,0x10,0x11,0x90,0x20,0x50,0x40,

		0x00,0x00,0xFE,0x3F,0x02,0x20,0x02,0x20,0x42,0x28,0x4A,0x29,0x52,0x2A,0x22,0x24,
		0x22,0x24,0x52,0x2A,0x52,0x2A,0x4A,0x29,0x86,0x20,0x02,0x20,0x02,0x28,0x02,0x10,

		0x00,0x00,0x00,0x00,0xFE,0x3F,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
		0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xFF,0x7F,0x00,0x00,0x00,0x00,

		0x10,0x00,0xB8,0x3F,0x8F,0x20,0x88,0x20,0x88,0x20,0xBF,0x3F,0x08,0x00,0x0C,0x00,
		0x9C,0x7F,0x2A,0x04,0x2A,0x04,0x89,0x3F,0x08,0x04,0x08,0x04,0xC8,0x7F,0x08,0x00,
			
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		}; 

		uchar code led4[] ={//一八级一班
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x7F,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x00,0x00,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x04,
		0x10,0x04,0x10,0x04,0x10,0x08,0x08,0x08,0x08,0x10,0x04,0x10,0x04,0x20,0x02,0x40,

		0x08,0x00,0xC8,0x3F,0x04,0x21,0x04,0x11,0x12,0x11,0x1F,0x09,0x08,0x39,0x04,0x21,
		0x82,0x22,0x9F,0x22,0x82,0x14,0x80,0x14,0x58,0x08,0x47,0x14,0x22,0x22,0x80,0x41,

		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x7F,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x00,0x01,0x00,0x01,0x1F,0x7D,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x5F,0x7D,
		0x44,0x11,0x24,0x11,0x04,0x11,0x9C,0x10,0x87,0x10,0x42,0x7C,0x20,0x00,0x10,0x00,
			
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		}; 

		uchar code led5[] ={//小学期实习
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x88,0x08,0x88,0x10,0x88,0x20,
		0x84,0x20,0x84,0x40,0x82,0x40,0x81,0x40,0x80,0x00,0x80,0x00,0xA0,0x00,0x40,0x00,

		0x44,0x10,0x88,0x10,0x88,0x08,0x00,0x04,0xFE,0x7F,0x02,0x40,0x01,0x20,0xF8,0x07,
		0x00,0x02,0x80,0x01,0xFF,0x7F,0x80,0x00,0x80,0x00,0x80,0x00,0xA0,0x00,0x40,0x00,

		0x44,0x00,0x44,0x3E,0xFE,0x22,0x44,0x22,0x44,0x22,0x7C,0x3E,0x44,0x22,0x44,0x22,
		0x7C,0x22,0x44,0x3E,0x44,0x22,0xFF,0x22,0x20,0x21,0x44,0x21,0x82,0x28,0x41,0x10,

		0x40,0x00,0x80,0x00,0xFE,0x7F,0x02,0x40,0x11,0x21,0x20,0x01,0x20,0x01,0x08,0x01,
		0x10,0x01,0x10,0x01,0xFF,0x7F,0x80,0x02,0x40,0x04,0x20,0x08,0x18,0x10,0x06,0x20,

		0x00,0x04,0x1F,0x04,0x10,0x0A,0x12,0x0A,0x12,0x11,0x92,0x20,0x52,0x5F,0x3E,0x00,
		0x20,0x22,0x20,0x24,0xB8,0x24,0x27,0x15,0x22,0x11,0x20,0x08,0xD4,0x7F,0x08,0x00,
			
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		}; 


		void shift(uchar data1,uchar data2);
		void delay(uint n);
		void State(uint n);
		void Btn_RST();
		void Btn_last(uint n);
		void Btn_next(uint n);

		void main(){
			State(1);
		}


		void shift(uchar data1,uchar data2)  {
			uchar i;
			STCP = 0;	
			for(i = 0; i < 8; i++){
				SHCP = 0;
				if(data1  & 0x80) 
					DS = 1;
				else 
					DS = 0;
				data1 <<= 1;
				SHCP = 1;
			}
			for(i = 0;i < 8; i++){
				SHCP = 0;
				if(data2 &0x80) 
					DS = 1;
				else 
					DS =0 ;
				data2 <<= 1;
				SHCP = 1;
			}
			STCP = 1;
		}

		void delay(uint n){
			uint i, j;
			for(i = 0; i < n; i++);
				for(j = 0; j < 110; j++);
		}

		void State(uint n){
			uchar i, x = 0;
			uint j;
			while(1){
				for(j = 0; j < 6; j++)
					for(i = 0;i < 16; i++){
						P1 = i;
						if(n == 1)
							shift(led1[2*i+2*x+1],led1[2*i+2*x]);
						else if(n == 2)
							shift(led2[2*i+2*x+1],led2[2*i+2*x]);
						else if(n == 3)
							shift(led3[2*i+2*x+1],led3[2*i+2*x]);
						else if(n == 4)
							shift(led4[2*i+2*x+1],led4[2*i+2*x]);
						else if(n == 5)
							shift(led5[2*i+2*x+1],led5[2*i+2*x]);
						delay(4);
					}
					
				x++;
				if(x == 96) 
					x = 0;
					
				if(Last == 0){
					delay(4);
					Btn_last(n);
				}
				if(Next == 0){
					delay(4);
					Btn_next(n);
				}
				if(Rst == 0){
					delay(4);
					Btn_RST();
				}
			}
		}

		void Btn_RST(){
			delay(4);
			while(1)
				State(1);
		}

		void Btn_last(uint n){
			delay(4);
			if(n == 1){
				while(1)
					State(5);
			}
			else if(n == 2){
				while(1)
					State(1);
			}
			else if(n == 3){
				while(1)
					State(2);
			}
			else if(n == 4){
				while(1)
					State(3);
			}
			else if(n == 5){
				while(1)
					State(4);
			}
		}
		void Btn_next(uint n)
		{
			delay(4);
			if(n == 1){
				while(1)
					State(2);
			}
			else if(n == 2){
				while(1)
					State(3);
			}
			else if(n == 3){
				while(1)
					State(4);
			}
			else if(n == 4){
				while(1)
					State(5);
			}
			else if(n == 5){
				while(1)
					State(1);
			}
		}										
													</pre></dt>
													<dt><h4>系统演示</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍视频如下
													</dt>
													<dt align="center"><embed src="images/IOT-v2.mp4" height="550" width="960"/></dt>
													<dt><h4>本项目遇到的主要问题及解决方法</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本项目主要是点阵拼接的问题。
													首先是在Proteus里8x8拼接成16x16点阵的问题，最开始没有去深入了解点阵拼接，导致拼接错误，后续去认真了解了点阵扫描原理，看了一篇博客中详细拼接方法，才正确拼接出16x16点阵，四块点阵的LED实际并未接在一起。
													在AD中画原理图与PCB图时，发现AD也没有16x16的点阵封装，只能自己从网上找了相似的焊盘自己画。
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
													</dt>
													</dl>
											</section>

											<section>
												<h3>3、汽车车速计</h3>
												<dl>
													<dt><h4>题目要求</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本项目是基于实际生活中现有车速计，利用安装在车轮上的脉冲，计算显示出车速、公里数信息
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依据题目要求，设计了四位LED数码管显示屏，设计了两个功能按键，一个是change键，用来切换显示屏显示的是速度还是路程。
													并且，为了更加清楚的区分显示，设置了两个LED提示灯，用来提示现在显示的是速度还是里程。另一个是clear键，用来清零路程，实现路程的计算
													</dt>
													<dt><h4>设计思路</h4></dt>
													<dt><b>硬件框图</b></dt>
													<dt align="center"><img src="images/IOT-3-1.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题的思路非常简单，主要是理解现有汽车车速计原理，其实利用车轮上的脉冲传感器，车轮没转一圈产生一个脉冲，利用1s内的脉冲数，得到车轮所转的圈数，通过计算速度；
													并且，车辆计轮胎是固定规格的，即车辆周长可知，也就是说，轮胎转一圈走过的距离是固定的，通过脉冲数乘以周长即可得到里程数
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本设计选取了225/60 R17型轮胎，按照国际标准计算公式以及相关资料查找，此型号轮胎半径为35.09cm，周长约为220.47cm
													</dt>
													<dt><b>Proteus仿真图</b></dt>
													<dt align="center"><img src="images/IOT-3-2.jpg"></dt>
													<dt><b>原理图</b></dt>
													<dt align="center"><img src="images/IOT-3-3.jpg"></dt>
													<dt><b>PCB版图</b></dt>
													<dt align="center"><img src="images/IOT-3-4.jpg"></dt>
													<dt><h4>编程实现</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题流程也相对简单，主要是脉冲数目的读取，利用定时器，通过中断0得到脉冲信号为低电平的数目，每到1s时，中断数变量清零重新计算，最终得到脉冲数，通过计算公式计算出速度与里程
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总体流程图如下
													</dt>
													<dt align="center"><img src="images/IOT-3-5.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体代码如下
													</dt>
													<dt><pre>
		#include <reg51.h>
		#define uchar unsigned char
		#define uint  unsigned int

		sbit dis = P1^3;
		sbit sp = P1^4;
		sbit change = P1^5;
		sbit clear = P1^6;

		const uint cnt = 8;
		uint t = 0; 
		uint speed, distance;
		uint pulse_time, pulse_cnt, pulse;
		uint flag = 1, set = 1;
		uchar code table[16]={0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};

		void delay(uchar m){
			uchar i,y;
			for(i = 0; i < m; i++)
				for(y = 0; y < 110; y++);
		}

		void init(){
			EX0 = 1;
			PX0 = 1;
			IT0 = 1;
			TMOD = 0x11;
			ET1 = 1;
			TR1 = 1;
			TH1 = (65535 - 25000) / 256;   
			TL1 = (65535 - 25000) % 256;//1.25ms
			EA=1;  
			distance = 0;	
		}

		void display(uint num){
			if(num >= 0 && num < 10){
				P2 = 0X08;
				P0 = table[num];        
				delay(3);
				P0 = 0XFF;
			}
			if(num >= 10 && num < 100){
				P2 = 0X08;
				P0 = table[num/10];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X04;
				P0 = table[num % 10];
				delay(3);
				P0 = 0XFF;
			}
			if(num >= 100 && num < 1000){
				P2 = 0X08;
				P0 = table[num / 100];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X04;
				P0 = table[num%100/10];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X02;
				P0 = table[num%100%10];
				delay(3);
				P0 = 0XFF;
			}
			if(num >= 1000 && num < 10000){
				P2 = 0X08;
				P0 = table[num/1000];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X04;
				P0 = table[num%1000/100];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X02;
				P0 = table[num%1000%100/10];
				delay(3);
				P0 = 0XFF;
				
				P2 = 0X01;
				P0 = table[num%1000%100%10];
				delay(3);
				P0 = 0XFF;
			}
		}

		void TIME1() interrupt 3
		{
			t++;
			pulse_time++;
			if(pulse_time == 40)  //1000ms(1s){
					pulse_time = 0;   
					pulse = pulse_cnt / 2;    
					pulse_cnt=0;     
					pulse = pulse - 2;
				}
		}

		void IINT0() interrupt 0{
			pulse_cnt++; 	
		}

		void main(){
			init();
			delay(10);
			
			while(1){
				speed = pulse * 2.2047 * 3.6;
				distance = pulse * 2.2047 * t * 0.001;
				if(flag == 1){
					sp = 1;
					dis = 0;
				}
				else{
					sp = 0;
					dis = 1;
				}
				if(change == 0){
					delay(5);
					flag = -flag;
				}
				if(clear == 0){
					t = 0;
					distance = 0;
				}
				if(flag == 1){
					//display(pulse);
					display(speed);
				}
				else{
					delay(5);
					display(distance);
				}	
			}
		}										
													</pre></dt>
													<dt><h4>系统演示</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍视频如下
													</dt>
													<dt align="center"><embed src="images/IOT-v3.mp4" height="550" width="960"/></dt>
													<dt><h4>本项目遇到的主要问题及解决方法</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最开始不太熟悉脉冲等用法，相关资料也比较少，因此最开始错误的使用了信号发生器，导致一直出不来结果。
													后期发现问题以后，发现读取的脉冲非常不稳，时常跳变，又通过延时，增加变量处理等使其显示平稳。后面又发现，得到的脉冲计算出的结果与实际不符，发现还是脉冲读取的问题，读取的脉冲数存在误差，
													即使是存在1个误差，由于乘了轮胎周长和单位换算以后，使得误差变得非常大。后期的解决办法是，通过多组观察，发现读取出的脉冲数总是比实际多2，因此在计算前减去这个误差，即可得到准确的速度
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面关于里程，最开始想用米做单位，充分显示里程的增加，发现增加的过快，导致四位数一直在变无法看清，因此只能用千米做单位，显示的结果略微不精确
													</dt>
													</dl>
											</section>

											<section>
												<h3>4、交通灯控制系统</h3>
												<dl>
													<dt><h4>题目要求</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用单片机设计交通灯控制系统，基本功能参考现有交通灯控制系统。
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在题目基础要求之上，增加了一些设计：
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在红灯或绿灯最后五秒，灯会闪烁示意
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.设计了三个功能按键，一个是禁止通行按键，
													按下以后四个路口都会变成红灯，再按一次恢复初态。第二个是南北通行按键，按下后会先变成黄灯缓冲，然后南北变为绿灯，东西变为红灯。第三个是东西通行按键，与南北同理
													</dt>
													<dt><h4>设计思路</h4></dt>
													<dt><b>硬件框图</b></dt>
													<dt align="center"><img src="images/IOT-4-1.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题的思路非常简单，就是利用AT89C51控制，道路交通灯指示采用红黄绿发光二极管，南北通行、东西通行各两个、其倒计时显示采用LED数码管，为共阳极接法。
													其电路按照红绿灯依次摆放，载分别放上四块显示屏即可
													</dt>
													<dt><b>Proteus仿真图</b></dt>
													<dt align="center"><img src="images/IOT-4-2.jpg"></dt>
													<dt><b>原理图</b></dt>
													<dt align="center"><img src="images/IOT-4-3.jpg"></dt>
													<dt><b>PCB版图</b></dt>
													<dt align="center"><img src="images/IOT-4-4.jpg"></dt>
													<dt><h4>编程实现</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其代码相对流程也非常简单，就是通过设计不同状态实现红绿灯的切换，按键的功能实现也是跳转到响应的状态
													</dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态如下
													</dt>
													<dt align="center"><img src="images/IOT-4-5.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总体流程图如下
													</dt>
													<dt align="center"><img src="images/IOT-4-6.jpg"></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体代码如下
													</dt>
													<dt><pre>
		#include <reg51.h>	

		#define uchar unsigned char
		#define uint  unsigned int	

		uint decede1, unit1, decede2, unit2, n;
		uint set = -1;
		uchar flag1 = 0, flag2 = 1;//State

		sbit Btn_Stop = P1^7;
		sbit Btn_EW = P2^6;
		sbit Btn_NS = P2^7;

		sbit RED_NS = P2^2;	
		sbit Yellow_NS = P2^1;
		sbit Green_NS = P2^0;

		sbit Red_EW = P2^5;	
		sbit Yellow_EW = P2^4;
		sbit Green_EW = P2^3;

		sbit Choose1_EW = P3^3;
		sbit Choose2_EW = P3^4;
		sbit Choose1_NS = P3^1;
		sbit Choose2_NS = P3^0;


		uint code table[]={0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};

		void display(uint decede1, uint unit1, uint decede2, uint unit2);
		void delay(uint m);
		void State1();
		void State2();
		void State3();
		void State4();
		void State5();
		void State6();
		void State7();
		void Stop();
		void Green_N();
		void Green_E();			

		void main(){
			P0 = 0xff;  
			P1 = 0xff; 
			P2 = 0xff; 
			P3 = 0xff; 
			
			while(1){
				uchar flag1 = 0, flag2 = 0;
				if(Btn_Stop == 0){
					delay(5);
					set = -set;
					Stop();
					P1 = 0xff;
				}
				if(Btn_NS == 0){
					delay(5);
					Green_N();
					P1 = 0xff;
				}
				if(Btn_EW == 0){
					delay(5);
					Green_E();
					P1 = 0xff;
				}
				if(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
					State1();//N&S red light 20s, E&W green light 15s
					State2();//N&S red light 10s, E&W green light blinking 5s
					State3();//N&S red light blinking 5s, E&W yellow light 5s
					State4();//N&S yellow light 5s, E&W red light 20s
					State5();//N&S green light 15s, E&W red light 15s
					State6();//N&S green light bliking 5s, E&W red light blinking 5s
					State7();//N&S yellow light 5s, E&W yellow light 5s
				}
			}
		}

		void delay(uint m)	{
			uint i, j;
			for(i = 0; i < m; i++)			
			for(j = 0; j < 110; j++);		
		}

		void Stop(){
			delay(5);
			while(set == 1){
				RED_NS = 0;	Yellow_NS = 1;Green_NS = 1;
				Red_EW = 0;	Yellow_EW = 1;Green_EW = 1;
				if(Btn_Stop == 0){
					break;
				}
			}
		}

		void Green_N(){
			delay(5);
			flag1 = 6; flag2 = 1;
			State7();
			flag1 = 4; flag2 = 1;
			State5();
			State6(); 
			State7();
		}

		void Green_E(){
			delay(5);
			flag1 = 6; flag2 = 1;
			State7();
		}

		void State1()//N&S red light 20s, E&W green light 15s{
			uint tmp1, tmp2;
			tmp1 = 15;
			tmp2 = 20;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 0 && flag2 == 1){
					flag2 = 0;
					tmp1--;
					tmp2--;
					RED_NS = 0;	Yellow_NS = 1;Green_NS = 1;
					Red_EW = 1;	Yellow_EW = 1;Green_EW = 0;
					
					decede1 = tmp1 / 10; unit1 = tmp1 % 10;
					decede2 = tmp2 / 10; unit2 = tmp2 % 10;
					if(tmp1 == 5){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 1;
		}
			
		void State2()//N&S red light 10s, E&W green light blinking 5s{
			uint tmp1, tmp2;
			tmp1 = 5;
			tmp2 = 10;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 1 && flag2 == 1){
					flag2 = 0;
					tmp1--;
					tmp2--;
					RED_NS = 0;	Yellow_NS = 1;Green_NS = 1;
					Red_EW = 1;	Yellow_EW = 1;Green_EW = ~Green_EW;
					
					decede1 = 0; unit1 = tmp1 % 10;
					decede2 = tmp2 / 10; unit2 = tmp2 % 10;
					if(tmp1 == 0){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 2;
		}

		void State3()//N&S red light blinking 5s, E&W yellow light 5s{
			uint tmp1, tmp2;
			tmp1 = 5;
			tmp2 = 5;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 2 && flag2 == 1){
					flag2 = 0;
					tmp1--;tmp2--;
					RED_NS = ~RED_NS;	Yellow_NS = 1;Green_NS = 1;
					Red_EW = 1;	Yellow_EW = 0;Green_EW = 1;
					
					decede1 = 0; unit1 = tmp1 % 10;
					decede2 = 0; unit2 = tmp2 % 10;
					if(tmp2 == 0){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 3;
		}

		void State4()//N&S yellow light 5s, E&W red light 20s{
			uint tmp1, tmp2;
			tmp1 = 20;
			tmp2 = 5;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 3 && flag2 == 1){
					flag2 = 0;
					tmp1--;
					tmp2--;
					RED_NS = 1;	Yellow_NS = 0;Green_NS = 1;
					Red_EW = 0;	Yellow_EW = 1;Green_EW = 1;
					
					decede1 = tmp1 / 10; unit1 = tmp1 % 10;
					decede2 = tmp2 / 10; unit2 = tmp2 % 10;
					if(tmp2 == 0){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 4;	
		}

		void State5()//N&S green light 15s, E&W red light 15s{
			uint tmp1, tmp2;
			tmp1 = 15;
			tmp2 = 15;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 4 && flag2 == 1){
					flag2 = 0;
					tmp1--;
					tmp2--;
					RED_NS = 1;	Yellow_NS = 1;Green_NS = 0;
					Red_EW = 0;	Yellow_EW = 1;Green_EW = 1;
					
					decede1 = tmp1 / 10; unit1 = tmp1 % 10;
					decede2 = tmp2 / 10; unit2 = tmp2 % 10;
					if(tmp1 == 5){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 5;		
		}

		void State6()//N&S green light bliking 5s, E&W red light blinking 5s{
			uint tmp1, tmp2;
			tmp1 = 5;
			tmp2 = 5;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 5 && flag2 == 1){
					flag2 = 0;
					tmp1--;
					tmp2--;
					RED_NS = 1;	Yellow_NS = 1;Green_NS = ~Green_NS;
					Red_EW = ~Red_EW;	Yellow_EW = 1;Green_EW = 1;
					
					decede1 = 0; unit1 = tmp1 % 10;
					decede2 = 0; unit2 = tmp2 % 10;
					
					if(tmp2 == 0){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 6;		
		}

		void State7()//N&S yellow light 5s, E&W yellow light 5s{
			uint tmp1, tmp2;
			tmp1 = 5;
			tmp2 = 5;
			TMOD = 0x01;
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			EA = 1;
			ET0 = 1;
			TR0 = 1;
			
			while(Btn_Stop==1 && Btn_NS==1 && Btn_EW==1){
				if(flag1 == 6 && flag2 == 1){
					flag2 = 0;
					tmp1--;
					tmp2--;
					RED_NS = 1;	Yellow_NS = 0;Green_NS = 1;
					Red_EW = 1;	Yellow_EW = 0;Green_EW = 1;
					
					decede1 = 0; unit1 = tmp1 % 10;
					decede2 = 0; unit2 = tmp2 % 10;
					
					if(tmp2 == 0){
						break;
					}
				}
				display(unit1, decede1, unit2, decede2);
			}
			flag1 = 0;	
		}

		void timer0() interrupt 1{
			TH0 = (65535 - 50000) / 256;
			TL0 = (65535 - 50000) % 256;
			if(++n>= 20){
				n = 0;
				flag2 = 1;
			}
		}

		void display(uint decede1, uint unit1, uint decede2, uint unit2){
			P3 = 0x00;
			Choose1_EW = 1;
			P1 = ~table[unit1];
			delay(5);
			
			P3 = 0x00;
			Choose2_EW = 1;
			P1 = ~table[decede1];
			delay(5);
			
			P3 = 0x00;
			Choose1_NS = 1;
			P1 = ~table[unit2];
			delay(5);
			
			P3 = 0x00;
			Choose2_NS = 1;
			P1 = ~table[decede2];
			delay(5);
		}										
													</pre></dt>
													<dt><h4>系统演示</h4></dt>
													<dt>
													&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍视频如下
													</dt>
													<dt align="center"><embed src="images/IOT-v4.mp4" height="550" width="960"/></dt>
													</dl>
											</section>

										</article>

								</div>
							</div>
							<div class="col-12">

								<!-- Features -->
									<section class="box features">
										<h2 class="major"><span>Thank you for your reading</span></h2>
									</section>

							</div>
						</div>
					</div>
				</section>

			<!-- Footer -->
				<footer id="footer">
					<div class="container">
						<div class="row gtr-200">
							<div class="col-12">
								<!-- Contact -->
									<section>
										<h2 class="major"><span>More</span></h2>
										<ul class="contact">
											<li><a href="https://blog.csdn.net/weixin_43476037"><img src="images/csdn.jpg" alt=""><span class="label"></span></a></li>
										</ul>
									</section>

							</div>
						</div>

						<!-- Copyright -->
							<div id="copyright">
								<ul class="menu">
									<li>&copy; Untitled. All rights reserved</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
								</ul>
							</div>

					</div>
				</footer>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>